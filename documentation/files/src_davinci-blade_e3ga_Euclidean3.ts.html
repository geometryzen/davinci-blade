<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/davinci-blade/e3ga/Euclidean3.ts - davinci-blade</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../../assets/logo.png" title="davinci-blade"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.7.2</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Dimensions.html">Dimensions</a></li>
                                <li><a href="../classes/Euclidean1.html">Euclidean1</a></li>
                                <li><a href="../classes/Euclidean2.html">Euclidean2</a></li>
                                <li><a href="../classes/Euclidean3.html">Euclidean3</a></li>
                                <li><a href="../classes/Rational.html">Rational</a></li>
                                <li><a href="../classes/Unit.html">Unit</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/blade.html">blade</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/davinci-blade/e3ga/Euclidean3.ts</h1>

<div class="file">
    <pre class="code prettyprint linenums">
import Measure = require(&#x27;davinci-blade/Measure&#x27;);
import NotImplementedError = require(&#x27;davinci-blade/NotImplementedError&#x27;);
import Unit = require(&#x27;davinci-blade/Unit&#x27;);
import core = require(&#x27;davinci-blade/core&#x27;);

var cos  = Math.cos;
var cosh = core.Math.cosh;
var exp  = Math.exp;
var sin  = Math.sin;
var sinh = core.Math.sinh;

function Euclidean3Error(message: string) {
  this.name = &#x27;Euclidean3Error&#x27;;
  this.message = (message || &quot;&quot;)
}
Euclidean3Error.prototype = new Error();

function assertArgNumber(name: string, x: number): number {
  if (typeof x === &#x27;number&#x27;) {
    return x;
  }
  else {
    throw new Euclidean3Error(&quot;Argument &#x27;&quot; + name + &quot;&#x27; must be a number&quot;);
  }
}

function assertArgEuclidean3(name: string, arg: Euclidean3): Euclidean3 {
  if (arg instanceof Euclidean3) {
    return arg;
  }
  else {
    throw new Euclidean3Error(&quot;Argument &#x27;&quot; + arg + &quot;&#x27; must be a Euclidean3&quot;);
  }
}

function assertArgUnitOrUndefined(name: string, uom: Unit): Unit {
  if (typeof uom === &#x27;undefined&#x27; || uom instanceof Unit) {
    return uom;
  }
  else {
    throw new Euclidean3Error(&quot;Argument &#x27;&quot; + uom + &quot;&#x27; must be a Unit or undefined&quot;);
  }
}

function compute(
  f: (x0: number, x1: number, x2: number, x3: number, x4: number, x5: number, x6: number, x7: number, y0: number, y1: number, y2: number, y3: number, y4: number, y5: number, y6: number, y7: number, index: number) =&gt; number,
  a: number[],
  b: number[],
  coord: (m: number[], index: number) =&gt; number,
  pack: (x0: number, x1: number, x2: number, x3: number, x4: number, x5: number, x6: number, x7: number, uom: Unit) =&gt; Euclidean3,
  uom: Unit): Euclidean3 {
    var a0 = coord(a, 0);
    var a1 = coord(a, 1);
    var a2 = coord(a, 2);
    var a3 = coord(a, 3);
    var a4 = coord(a, 4);
    var a5 = coord(a, 5);
    var a6 = coord(a, 6);
    var a7 = coord(a, 7);
    var b0 = coord(b, 0);
    var b1 = coord(b, 1);
    var b2 = coord(b, 2);
    var b3 = coord(b, 3);
    var b4 = coord(b, 4);
    var b5 = coord(b, 5);
    var b6 = coord(b, 6);
    var b7 = coord(b, 7);
    var x0 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 0);
    var x1 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 1);
    var x2 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 2);
    var x3 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 3);
    var x4 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 4);
    var x5 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 5);
    var x6 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 6);
    var x7 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 7);
    return pack(x0, x1, x2, x3, x4, x5, x6, x7, uom);
}

function addE3(a0: number, a1: number, a2: number, a3: number, a4: number, a5: number, a6: number, a7: number, b0: number, b1: number, b2: number, b3: number, b4: number, b5: number, b6: number, b7: number, index: number): number {
  a0 = +a0;
  a1 = +a1;
  a2 = +a2;
  a3 = +a3;
  a4 = +a4;
  a5 = +a5;
  a6 = +a6;
  a7 = +a7;
  b0 = +b0;
  b1 = +b1;
  b2 = +b2;
  b3 = +b3;
  b4 = +b4;
  b5 = +b5;
  b6 = +b6;
  b7 = +b7;
  index = index | 0;
  var x = 0.0;
  switch (~(~index)) {
      case 0: {
          x = +(a0 + b0);
      }
      break;
      case 1: {
          x = +(a1 + b1);
      }
      break;
      case 2: {
          x = +(a2 + b2);
      }
      break;
      case 3: {
          x = +(a3 + b3);
      }
      break;
      case 4: {
          x = +(a4 + b4);
      }
      break;
      case 5: {
          x = +(a5 + b5);
      }
      break;
      case 6: {
          x = +(a6 + b6);
      }
      break;
      case 7: {
          x = +(a7 + b7);
      }
      break;
      default: {
        throw new Euclidean3Error(&quot;index must be in the range [0..7]&quot;);
      }
  }
  return +x;
}

function subE3(a0: number, a1: number, a2: number, a3: number, a4: number, a5: number, a6: number, a7: number, b0: number, b1: number, b2: number, b3: number, b4: number, b5: number, b6: number, b7: number, index: number): number {
    a0 = +a0;
    a1 = +a1;
    a2 = +a2;
    a3 = +a3;
    a4 = +a4;
    a5 = +a5;
    a6 = +a6;
    a7 = +a7;
    b0 = +b0;
    b1 = +b1;
    b2 = +b2;
    b3 = +b3;
    b4 = +b4;
    b5 = +b5;
    b6 = +b6;
    b7 = +b7;
    index = index | 0;
    var x = 0.0;
    switch (~(~index)) {
        case 0: {
            x = +(a0 - b0);
        }
            break;
        case 1: {
            x = +(a1 - b1);
        }
            break;
        case 2: {
            x = +(a2 - b2);
        }
            break;
        case 3: {
            x = +(a3 - b3);
        }
            break;
        case 4: {
            x = +(a4 - b4);
        }
            break;
        case 5: {
            x = +(a5 - b5);
        }
            break;
        case 6: {
            x = +(a6 - b6);
        }
            break;
        case 7: {
            x = +(a7 - b7);
        }
            break;
        default: {
            throw new Euclidean3Error(&quot;index must be in the range [0..7]&quot;);
        }
    }
    return +x;
}

/**
 * 
 */
function mulE3(a0: number, a1: number, a2: number, a3: number, a4: number, a5: number, a6: number, a7: number, b0: number, b1: number, b2: number, b3: number, b4: number, b5: number, b6: number, b7: number, index: number): number {
    a0 = +a0;
    a1 = +a1;
    a2 = +a2;
    a3 = +a3;
    a4 = +a4;
    a5 = +a5;
    a6 = +a6;
    a7 = +a7;
    b0 = +b0;
    b1 = +b1;
    b2 = +b2;
    b3 = +b3;
    b4 = +b4;
    b5 = +b5;
    b6 = +b6;
    b7 = +b7;
    index = index | 0;
    var x = 0.0;
    switch (~(~index)) {
        case 0: {
            x = +(a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3 - a4 * b4 - a5 * b5 - a6 * b6 - a7 * b7);
        }
            break;
        case 1: {
            x = +(a0 * b1 + a1 * b0 - a2 * b4 + a3 * b6 + a4 * b2 - a5 * b7 - a6 * b3 - a7 * b5);
        }
            break;
        case 2: {
            x = +(a0 * b2 + a1 * b4 + a2 * b0 - a3 * b5 - a4 * b1 + a5 * b3 - a6 * b7 - a7 * b6);
        }
            break;
        case 3: {
            x = +(a0 * b3 - a1 * b6 + a2 * b5 + a3 * b0 - a4 * b7 - a5 * b2 + a6 * b1 - a7 * b4);
        }
            break;
        case 4: {
            x = +(a0 * b4 + a1 * b2 - a2 * b1 + a3 * b7 + a4 * b0 - a5 * b6 + a6 * b5 + a7 * b3);
        }
            break;
        case 5: {
            x = +(a0 * b5 + a1 * b7 + a2 * b3 - a3 * b2 + a4 * b6 + a5 * b0 - a6 * b4 + a7 * b1);
        }
            break;
        case 6: {
            x = +(a0 * b6 - a1 * b3 + a2 * b7 + a3 * b1 - a4 * b5 + a5 * b4 + a6 * b0 + a7 * b2);
        }
            break;
        case 7: {
            x = +(a0 * b7 + a1 * b5 + a2 * b6 + a3 * b4 + a4 * b3 + a5 * b1 + a6 * b2 + a7 * b0);
        }
            break;
        default: {
            throw new Euclidean3Error(&quot;index must be in the range [0..7]&quot;);
        }
    }
    return +x;
}

function scpE3(a0: number, a1: number, a2: number, a3: number, a4: number, a5: number, a6: number, a7: number, b0: number, b1: number, b2: number, b3: number, b4: number, b5: number, b6: number, b7: number, index: number): number {
    a0 = +a0;
    a1 = +a1;
    a2 = +a2;
    a3 = +a3;
    a4 = +a4;
    a5 = +a5;
    a6 = +a6;
    a7 = +a7;
    b0 = +b0;
    b1 = +b1;
    b2 = +b2;
    b3 = +b3;
    b4 = +b4;
    b5 = +b5;
    b6 = +b6;
    b7 = +b7;
    index = index | 0;
    var x = 0.0;
    switch (~(~index)) {
        case 0: {
            x = +(a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3 - a4 * b4 - a5 * b5 - a6 * b6 - a7 * b7);
        }
            break;
        case 1: {
            x = 0;
        }
            break;
        case 2: {
            x = 0;
        }
            break;
        case 3: {
            x = 0;
        }
            break;
        case 4: {
            x = 0;
        }
            break;
        case 5: {
            x = 0;
        }
            break;
        case 6: {
            x = 0;
        }
            break;
        case 7: {
            x = 0;
        }
            break;
        default: {
            throw new Euclidean3Error(&quot;index must be in the range [0..7]&quot;);
        }
    }
    return +x;
}

function extE3(a0: number, a1: number, a2: number, a3: number, a4: number, a5: number, a6: number, a7: number, b0: number, b1: number, b2: number, b3: number, b4: number, b5: number, b6: number, b7: number, index: number): number {
    a0 = +a0;
    a1 = +a1;
    a2 = +a2;
    a3 = +a3;
    a4 = +a4;
    a5 = +a5;
    a6 = +a6;
    a7 = +a7;
    b0 = +b0;
    b1 = +b1;
    b2 = +b2;
    b3 = +b3;
    b4 = +b4;
    b5 = +b5;
    b6 = +b6;
    b7 = +b7;
    index = index | 0;
    var x = 0.0;
    switch (~(~index)) {
        case 0: {
            x = +(a0 * b0);
        }
            break;
        case 1: {
            x = +(a0 * b1 + a1 * b0);
        }
            break;
        case 2: {
            x = +(a0 * b2 + a2 * b0);
        }
            break;
        case 3: {
            x = +(a0 * b3 + a3 * b0);
        }
            break;
        case 4: {
            x = +(a0 * b4 + a1 * b2 - a2 * b1 + a4 * b0);
        }
            break;
        case 5: {
            x = +(a0 * b5 + a2 * b3 - a3 * b2 + a5 * b0);
        }
            break;
        case 6: {
            x = +(a0 * b6 - a1 * b3 + a3 * b1 + a6 * b0);
        }
            break;
        case 7: {
            x = +(a0 * b7 + a1 * b5 + a2 * b6 + a3 * b4 + a4 * b3 + a5 * b1 + a6 * b2 + a7 * b0);
        }
            break;
        default: {
            throw new Euclidean3Error(&quot;index must be in the range [0..7]&quot;);
        }
    }
    return +x;
}

function lcoE3(a0: number, a1: number, a2: number, a3: number, a4: number, a5: number, a6: number, a7: number, b0: number, b1: number, b2: number, b3: number, b4: number, b5: number, b6: number, b7: number, index: number): number {
    a0 = +a0;
    a1 = +a1;
    a2 = +a2;
    a3 = +a3;
    a4 = +a4;
    a5 = +a5;
    a6 = +a6;
    a7 = +a7;
    b0 = +b0;
    b1 = +b1;
    b2 = +b2;
    b3 = +b3;
    b4 = +b4;
    b5 = +b5;
    b6 = +b6;
    b7 = +b7;
    index = index | 0;
    var x = 0.0;
    switch (~(~index)) {
        case 0: {
            x = +(a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3 - a4 * b4 - a5 * b5 - a6 * b6 - a7 * b7);
        }
            break;
        case 1: {
            x = +(a0 * b1 - a2 * b4 + a3 * b6 - a5 * b7);
        }
            break;
        case 2: {
            x = +(a0 * b2 + a1 * b4 - a3 * b5 - a6 * b7);
        }
            break;
        case 3: {
            x = +(a0 * b3 - a1 * b6 + a2 * b5 - a4 * b7);
        }
            break;
        case 4: {
            x = +(a0 * b4 + a3 * b7);
        }
            break;
        case 5: {
            x = +(a0 * b5 + a1 * b7);
        }
            break;
        case 6: {
            x = +(a0 * b6 + a2 * b7);
        }
            break;
        case 7: {
            x = +(a0 * b7);
        }
            break;
        default: {
            throw new Euclidean3Error(&quot;index must be in the range [0..7]&quot;);
        }
    }
    return +x;
}

function rcoE3(a0: number, a1: number, a2: number, a3: number, a4: number, a5: number, a6: number, a7: number, b0: number, b1: number, b2: number, b3: number, b4: number, b5: number, b6: number, b7: number, index: number): number {
    a0 = +a0;
    a1 = +a1;
    a2 = +a2;
    a3 = +a3;
    a4 = +a4;
    a5 = +a5;
    a6 = +a6;
    a7 = +a7;
    b0 = +b0;
    b1 = +b1;
    b2 = +b2;
    b3 = +b3;
    b4 = +b4;
    b5 = +b5;
    b6 = +b6;
    b7 = +b7;
    index = index | 0;
    var x = 0.0;
    switch (~(~index)) {
        case 0: {
            x = +(a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3 - a4 * b4 - a5 * b5 - a6 * b6 - a7 * b7);
        }
            break;
        case 1: {
            x = +(+ a1 * b0 + a4 * b2 - a6 * b3 - a7 * b5);
        }
            break;
        case 2: {
            x = +(+ a2 * b0 - a4 * b1 + a5 * b3 - a7 * b6);
        }
            break;
        case 3: {
            x = +(+ a3 * b0 - a5 * b2 + a6 * b1 - a7 * b4);
        }
            break;
        case 4: {
            x = +(+ a4 * b0 + a7 * b3);
        }
            break;
        case 5: {
            x = +(+ a5 * b0 + a7 * b1);
        }
            break;
        case 6: {
            x = +(+ a6 * b0 + a7 * b2);
        }
            break;
        case 7: {
            x = +(+ a7 * b0);
        }
            break;
        default: {
            throw new Euclidean3Error(&quot;index must be in the range [0..7]&quot;);
        }
    }
    return +x;
}

var divide = function(
  a000: number,
  a001: number,
  a010: number,
  a011: number, a100, a101, a110, a111, b000, b001, b010, b011, b100, b101, b110, b111, uom: Unit, dst?: Euclidean3) {
    var c000, c001, c010, c011, c100, c101, c110, c111, i000, i001, i010, i011, i100, i101, i110, i111, k000, m000, m001, m010, m011, m100, m101, m110, m111, r000, r001, r010, r011, r100, r101, r110, r111, s000, s001, s010, s011, s100, s101, s110, s111, w, x, x000, x001, x010, x011, x100, x101, x110, x111, xy, xyz, y, yz, z, zx;

    r000 = +b000;
    r001 = +b001;
    r010 = +b010;
    r011 = -b011;
    r100 = +b100;
    r101 = -b101;
    r110 = -b110;
    r111 = -b111;
    m000 = mulE3(b000, b001, b010, b100, b011, b110, -b101, b111, r000, r001, r010, r100, r011, r110, -r101, r111, 0);
    m001 = mulE3(b000, b001, b010, b100, b011, b110, -b101, b111, r000, r001, r010, r100, r011, r110, -r101, r111, 1);
    m010 = mulE3(b000, b001, b010, b100, b011, b110, -b101, b111, r000, r001, r010, r100, r011, r110, -r101, r111, 2);
    m011 = 0;
    m100 = mulE3(b000, b001, b010, b100, b011, b110, -b101, b111, r000, r001, r010, r100, r011, r110, -r101, r111, 3);
    m101 = 0;
    m110 = 0;
    m111 = 0;
    c000 = +m000;
    c001 = -m001;
    c010 = -m010;
    c011 = -m011;
    c100 = -m100;
    c101 = -m101;
    c110 = -m110;
    c111 = +m111;
    s000 = mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 0);
    s001 = mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 1);
    s010 = mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 2);
    s011 = mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 4);
    s100 = mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 3);
    s101 = -mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 6);
    s110 = mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 5);
    s111 = mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 7);
    k000 = mulE3(b000, b001, b010, b100, b011, b110, -b101, b111, s000, s001, s010, s100, s011, s110, -s101, s111, 0);
    i000 = s000 / k000;
    i001 = s001 / k000;
    i010 = s010 / k000;
    i011 = s011 / k000;
    i100 = s100 / k000;
    i101 = s101 / k000;
    i110 = s110 / k000;
    i111 = s111 / k000;
    x000 = mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 0);
    x001 = mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 1);
    x010 = mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 2);
    x011 = mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 4);
    x100 = mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 3);
    x101 = -mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 6);
    x110 = mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 5);
    x111 = mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 7);
    w = x000;
    x = x001;
    y = x010;
    z = x100;
    xy = x011;
    yz = x110;
    zx = -x101;
    xyz = x111;
    if (typeof dst !== &#x27;undefined&#x27;) {
      dst.w = w;
      dst.x = x;
      dst.y = y;
      dst.z = z;
      dst.xy = xy;
      dst.yz = yz;
      dst.zx = zx;
      dst.xyz = xyz;
      dst.uom = uom;
    }
    else {
      return new Euclidean3(w, x, y, z, xy, yz, zx, xyz, uom);
    }
};

function stringFromCoordinates(
  coordinates: number[],
  numberToString: (x: number) =&gt; string,
  labels: string[]
  ): string {
    var i: number, _i: number, _ref: number;
    var str: string;
    var sb: string[] = [];
    var append = function(coord: number, label: string): void {
        var n;
        if (coord !== 0) {
            if (coord &gt;= 0) {
                if (sb.length &gt; 0) {
                    sb.push(&quot;+&quot;);
                }
            } else {
                sb.push(&quot;-&quot;);
            }
            n = Math.abs(coord);
            if (n === 1) {
                sb.push(label);
            } else {
                sb.push(numberToString(n));
                if (label !== &quot;1&quot;) {
                    sb.push(&quot;*&quot;);
                    sb.push(label);
                }
            }
        }
    };
    for (i = _i = 0, _ref = coordinates.length - 1; 0 &lt;= _ref ? _i &lt;= _ref : _i &gt;= _ref; i = 0 &lt;= _ref ? ++_i : --_i) {
        append(coordinates[i], labels[i]);
    }
    if (sb.length &gt; 0) {
        str = sb.join(&quot;&quot;);
    } else {
        str = &quot;0&quot;;
    }
    return str;
}

/**
 * The Euclidean3 class represents a multivector for a 3-dimensional vector space with a Euclidean metric.
 * @class Euclidean3
 */
class Euclidean3 implements Measure&lt;Euclidean3&gt; {
    /**
     * The &#x60;w&#x60; property is the grade zero (scalar) part of the Euclidean3 multivector.
     * @property w
     * @type number
     */
    public w: number;
    /**
     * The &#x60;x&#x60; property is the x coordinate of the grade one (vector) part of the Euclidean3 multivector.
     */
    public x: number;
    /**
     * The &#x60;y&#x60; property is the y coordinate of the grade one (vector) part of the Euclidean3 multivector.
     */
    public y: number;
    /**
     * The &#x60;z&#x60; property is the z coordinate of the grade one (vector) part of the Euclidean3 multivector.
     */
    public z: number;
    /**
     * The &#x60;xy&#x60; property is the xy coordinate of the grade two (bivector) part of the Euclidean3 multivector.
     */
    public xy: number;
    /**
     * The &#x60;yz&#x60; property is the yz coordinate of the grade two (bivector) part of the Euclidean3 multivector.
     */
    public yz: number;
    /**
     * The &#x60;zx&#x60; property is the zx coordinate of the grade two (bivector) part of the Euclidean3 multivector.
     */
    public zx: number;
    /**
     * The &#x60;xyz&#x60; property is the grade three (pseudoscalar) part of the Euclidean3 multivector.
     */
    public xyz: number;
    /**
     * The optional unit of measure.
     */
    public uom: Unit;
    /**
     * Constructs a Euclidean3 from its coordinates.
     * @constructor
     * @param {number} w The scalar part of the multivector.
     * @param {number} x The vector component of the multivector in the x-direction.
     * @param {number} y The vector component of the multivector in the y-direction.
     * @param {number} z The vector component of the multivector in the z-direction.
     * @param {number} xy The bivector component of the multivector in the xy-plane.
     * @param {number} yz The bivector component of the multivector in the yz-plane.
     * @param {number} zx The bivector component of the multivector in the zx-plane.
     * @param {number} xyz The pseudoscalar part of the multivector.
     * @param uom The optional unit of measure.
     */
    constructor(w: number, x: number, y: number, z: number, xy: number, yz: number, zx: number, xyz: number, uom?: Unit) {
      this.w = assertArgNumber(&#x27;w&#x27;, w);
      this.x = assertArgNumber(&#x27;x&#x27;, x);
      this.y = assertArgNumber(&#x27;y&#x27;, y);
      this.z = assertArgNumber(&#x27;z&#x27;, z);
      this.xy = assertArgNumber(&#x27;xy&#x27;, xy);
      this.yz = assertArgNumber(&#x27;yz&#x27;, yz);
      this.zx = assertArgNumber(&#x27;zx&#x27;, zx);
      this.xyz = assertArgNumber(&#x27;xyz&#x27;, xyz);
      this.uom = assertArgUnitOrUndefined(&#x27;uom&#x27;, uom);
      if (this.uom &amp;&amp; this.uom.scale !== 1) {
        var scale: number = this.uom.scale;
        this.w *= scale;
        this.x *= scale;
        this.y *= scale;
        this.z *= scale;
        this.xy *= scale;
        this.yz *= scale;
        this.zx *= scale;
        this.xyz *= scale;
        this.uom = new Unit(1, uom.dimensions, uom.labels);
      }
    }

    static fromCartesian(w: number, x: number, y: number, z: number, xy: number, yz: number, zx: number, xyz: number, uom: Unit): Euclidean3 {
      assertArgNumber(&#x27;w&#x27;, w);
      assertArgNumber(&#x27;x&#x27;, x);
      assertArgNumber(&#x27;y&#x27;, y);
      assertArgNumber(&#x27;z&#x27;, z);
      assertArgNumber(&#x27;xy&#x27;, xy);
      assertArgNumber(&#x27;yz&#x27;, yz);
      assertArgNumber(&#x27;zx&#x27;, zx);
      assertArgNumber(&#x27;xyz&#x27;, xyz);
      assertArgUnitOrUndefined(&#x27;uom&#x27;, uom);
      return new Euclidean3(w, x, y, z, xy, yz, zx, xyz, uom);
    }

    coordinates(): number[] {
      return [this.w, this.x, this.y, this.z, this.xy, this.yz, this.zx, this.xyz];
    }

    coordinate(index: number): number {
      assertArgNumber(&#x27;index&#x27;, index);
      switch (index) {
        case 0:
          return this.w;
        case 1:
          return this.x;
        case 2:
          return this.y;
        case 3:
          return this.z;
        case 4:
          return this.xy;
        case 5:
          return this.yz;
        case 6:
          return this.zx;
        case 7:
          return this.xyz;
        default:
          throw new Euclidean3Error(&quot;index must be in the range [0..7]&quot;);
      }
    }
    /**
     * Computes the sum of this Euclidean3 and another considered to be the rhs of the binary addition, &#x60;+&#x60;, operator.
     * This method does not change this Euclidean3.
     * @method add
     * @param rhs {Euclidean3}
     * @return {Euclidean3} This Euclidean3 plus rhs.
     */
    add(rhs: Euclidean3): Euclidean3 {
      var coord = function(x: number[], n: number): number {
        return x[n];
      };
      var pack = function(w: number, x: number, y: number, z: number, xy: number, yz: number, zx: number, xyz: number, uom: Unit): Euclidean3 {
        return Euclidean3.fromCartesian(w, x, y, z, xy, yz, zx, xyz, uom);
      };
      return compute(addE3, this.coordinates(), rhs.coordinates(), coord, pack, Unit.compatible(this.uom, rhs.uom));
    }

    __add__(other: any): Euclidean3 {
      if (other instanceof Euclidean3) {
        return this.add(other);
      }
      else if (typeof other === &#x27;number&#x27;) {
        return this.add(new Euclidean3(other, 0, 0, 0, 0, 0, 0, 0, void 0));
      }
    }

    __radd__(other: any): Euclidean3 {
      if (other instanceof Euclidean3) {
        return other.add(this);
      }
      else if (typeof other === &#x27;number&#x27;) {
        return new Euclidean3(other, 0, 0, 0, 0, 0, 0, 0, void 0).add(this);
      }
    }

    /**
     * Computes the difference of this Euclidean3 and another considered to be the rhs of the binary subtraction, &#x60;-&#x60;, operator.
     * This method does not change this Euclidean3.
     * @method sub
     * @param rhs {Euclidean3}
     * @return {Euclidean3} This Euclidean3 minus rhs.
     */
    sub(rhs: Euclidean3): Euclidean3 {
      var coord = function(x: number[], n: number): number {
        return x[n];
      };
      var pack = function(w, x, y, z, xy, yz, zx, xyz, uom: Unit): Euclidean3 {
        return Euclidean3.fromCartesian(w, x, y, z, xy, yz, zx, xyz, uom);
      };
      return compute(subE3, this.coordinates(), rhs.coordinates(), coord, pack, Unit.compatible(this.uom, rhs.uom));
    }

    __sub__(other: any): Euclidean3 {
      if (other instanceof Euclidean3) {
        return this.sub(other);
      }
      else if (typeof other === &#x27;number&#x27;) {
        return this.sub(new Euclidean3(other, 0, 0, 0, 0, 0, 0, 0, void 0));
      }
    }

    __rsub__(other: any): Euclidean3 {
      if (other instanceof Euclidean3) {
        return other.sub(this);
      }
      else if (typeof other === &#x27;number&#x27;) {
        return new Euclidean3(other, 0, 0, 0, 0, 0, 0, 0, void 0).sub(this);
      }
    }

    mul(rhs: Euclidean3): Euclidean3
    {
      var coord = function(x: number[], n: number): number {return x[n];};
      var pack = function(w, x, y, z, xy, yz, zx, xyz, uom: Unit) {return Euclidean3.fromCartesian(w, x, y, z, xy, yz, zx, xyz, uom);};
      return compute(mulE3, this.coordinates(), rhs.coordinates(), coord, pack, Unit.mul(this.uom, rhs.uom));
    }

    __mul__(other: any): any
    {
      if (other instanceof Euclidean3)
      {
        return this.mul(other);
      }
      else if (typeof other === &#x27;number&#x27;)
      {
        return this.mul(new Euclidean3(other, 0, 0, 0, 0, 0, 0, 0, void 0));
      }
    }

    __rmul__(other: any): any
    {
      if (other instanceof Euclidean3)
      {
        return other.mul(this);
      }
      else if (typeof other === &#x27;number&#x27;)
      {
        return new Euclidean3(other, 0, 0, 0, 0, 0, 0, 0, void 0).mul(this);
      }
    }

    scalarMultiply(rhs: number): Euclidean3 {
      return new Euclidean3(this.w * rhs, this.x * rhs, this.y * rhs, this.z * rhs, this.xy * rhs, this.yz * rhs, this.zx * rhs, this.xyz * rhs, this.uom);
    }

    div(rhs: Euclidean3): Euclidean3 {
      assertArgEuclidean3(&#x27;rhs&#x27;, rhs);
      return divide(this.w, this.x, this.y, this.xy, this.z, -this.zx, this.yz, this.xyz, rhs.w, rhs.x, rhs.y, rhs.xy, rhs.z, -rhs.zx, rhs.yz, rhs.xyz, Unit.div(this.uom,rhs.uom));
    }

    __div__(other: any): Euclidean3
    {
      if (other instanceof Euclidean3)
      {
        return this.div(other);
      }
      else if (typeof other === &#x27;number&#x27;)
      {
        return this.div(new Euclidean3(other, 0, 0, 0, 0, 0, 0, 0, void 0));
      }
    }

    __rdiv__(other: any): Euclidean3
    {
      if (other instanceof Euclidean3)
      {
        return other.div(this);
      }
      else if (typeof other === &#x27;number&#x27;)
      {
        return new Euclidean3(other, 0, 0, 0, 0, 0, 0, 0, void 0).div(this);
      }
    }

    splat(rhs: Euclidean3): Euclidean3 {
      var coord = function(x: number[], n: number): number {
        return x[n];
      };
      var pack = function(w, x, y, z, xy, yz, zx, xyz, uom: Unit): Euclidean3 {
        return Euclidean3.fromCartesian(w, x, y, z, xy, yz, zx, xyz, uom);
      };
      return compute(scpE3, this.coordinates(), rhs.coordinates(), coord, pack, Unit.mul(this.uom, rhs.uom));
    }

    wedge(rhs: Euclidean3): Euclidean3 {
      var coord = function(x: number[], n: number): number {
        return x[n];
      };
      var pack = function(w: number, x: number, y: number, z: number, xy: number, yz: number, zx: number, xyz: number, uom: Unit): Euclidean3 {
        return Euclidean3.fromCartesian(w, x, y, z, xy, yz, zx, xyz, uom);
      };
      return compute(extE3, this.coordinates(), rhs.coordinates(), coord, pack, Unit.mul(this.uom, rhs.uom));
    }

    __vbar__(other: any): Euclidean3 {
      if (other instanceof Euclidean3) {
        return this.splat(other);
      }
      else if (typeof other === &#x27;number&#x27;) {
        return this.splat(new Euclidean3(other, 0, 0, 0, 0, 0, 0, 0, void 0));
      }
    }

    __rvbar__(other: any): Euclidean3 {
      if (other instanceof Euclidean3) {
        return other.splat(this);
      }
      else if (typeof other === &#x27;number&#x27;) {
        return new Euclidean3(other, 0, 0, 0, 0, 0, 0, 0, void 0).splat(this);
      }
    }

    __wedge__(other: any): Euclidean3 {
      if (other instanceof Euclidean3) {
        return this.wedge(other);
      }
      else if (typeof other === &#x27;number&#x27;) {
        return this.wedge(new Euclidean3(other, 0, 0, 0, 0, 0, 0, 0, void 0));
      }
    }

    __rwedge__(other: any): Euclidean3 {
      if (other instanceof Euclidean3) {
        return other.wedge(this);
      }
      else if (typeof other === &#x27;number&#x27;) {
        return new Euclidean3(other, 0, 0, 0, 0, 0, 0, 0, void 0).wedge(this);
      }
    }

    lshift(rhs: Euclidean3): Euclidean3 {
      var coord = function(x: number[], n: number): number {
        return x[n];
      };
      var pack = function(w: number, x: number, y: number, z: number, xy: number, yz: number, zx: number, xyz: number, uom: Unit) {
        return Euclidean3.fromCartesian(w, x, y, z, xy, yz, zx, xyz, uom);
      };
      return compute(lcoE3, this.coordinates(), rhs.coordinates(), coord, pack, Unit.mul(this.uom, rhs.uom));
    }

    __lshift__(other: any): Euclidean3 {
      if (other instanceof Euclidean3) {
        return this.lshift(other);
      }
      else if (typeof other === &#x27;number&#x27;) {
        return this.lshift(new Euclidean3(other, 0, 0, 0, 0, 0, 0, 0, void 0));
      }
    }

    __rlshift__(other: any): Euclidean3 {
      if (other instanceof Euclidean3) {
        return other.lshift(this);
      }
      else if (typeof other === &#x27;number&#x27;) {
        return new Euclidean3(other, 0, 0, 0, 0, 0, 0, 0, void 0).lshift(this);
      }
    }

    rshift(rhs: Euclidean3): Euclidean3 {
      var coord = function(x: number[], n: number): number {
        return x[n];
      };
      var pack = function(w, x, y, z, xy, yz, zx, xyz, uom: Unit) {
        return Euclidean3.fromCartesian(w, x, y, z, xy, yz, zx, xyz, uom);
      };
      return compute(rcoE3, [this.w, this.x, this.y, this.z, this.xy, this.yz, this.zx, this.xyz], [rhs.w, rhs.x, rhs.y, rhs.z, rhs.xy, rhs.yz, rhs.zx, rhs.xyz], coord, pack, Unit.mul(this.uom, rhs.uom));
    }

    __rshift__(other: any): Euclidean3 {
      if (other instanceof Euclidean3) {
        return this.rshift(other);
      }
      else if (typeof other === &#x27;number&#x27;) {
        return this.rshift(new Euclidean3(other, 0, 0, 0, 0, 0, 0, 0, void 0));
      }
    }

    __rrshift__(other: any): Euclidean3 {
      if (other instanceof Euclidean3) {
        return other.rshift(this);
      }
      else if (typeof other === &#x27;number&#x27;) {
        return new Euclidean3(other, 0, 0, 0, 0, 0, 0, 0, void 0).rshift(this);
      }
    }

    pow(exponent: Euclidean3): Euclidean3 {
      // assertArgEuclidean3(&#x27;exponent&#x27;, exponent);
      throw new Euclidean3Error(&#x27;pow&#x27;);
    }

    __pos__(): Euclidean3 {
      return this;
    }

    __neg__(): Euclidean3 {
      return new Euclidean3(-this.w, -this.x, -this.y, -this.z, -this.xy, -this.yz, -this.zx, -this.xyz, this.uom);
    }

    /**
     * ~ (tilde) produces reversion.
     */
    __tilde__(): Euclidean3 {
      return new Euclidean3(this.w, this.x, this.y, this.z, -this.xy, -this.yz, -this.zx, -this.xyz, this.uom);
    }

    grade(index: number): Euclidean3 {
      assertArgNumber(&#x27;index&#x27;, index);
      switch (index) {
        case 0:
          return Euclidean3.fromCartesian(this.w, 0, 0, 0, 0, 0, 0, 0, this.uom);
        case 1:
          return Euclidean3.fromCartesian(0, this.x, this.y, this.z, 0, 0, 0, 0, this.uom);
        case 2:
          return Euclidean3.fromCartesian(0, 0, 0, 0, this.xy, this.yz, this.zx, 0, this.uom);
        case 3:
          return Euclidean3.fromCartesian(0, 0, 0, 0, 0, 0, 0, this.xyz, this.uom);
        default:
          return Euclidean3.fromCartesian(0, 0, 0, 0, 0, 0, 0, 0, this.uom);
      }
    }

    // FIXME: This should return a Euclidean3
    dot(vector: Euclidean3): number {
      return this.x * vector.x + this.y * vector.y + this.z * vector.z;
    }

    cross(vector: Euclidean3): Euclidean3 {
        var x, x1, x2, y, y1, y2, z, z1, z2;

        x1 = this.x;
        y1 = this.y;
        z1 = this.z;
        x2 = vector.x;
        y2 = vector.y;
        z2 = vector.z;
        x = y1 * z2 - z1 * y2;
        y = z1 * x2 - x1 * z2;
        z = x1 * y2 - y1 * x2;
        return new Euclidean3(0, x, y, z, 0, 0, 0, 0, Unit.mul(this.uom, vector.uom));
    }
    isZero(): boolean {
        return (this.w === 0) &amp;&amp; (this.x === 0) &amp;&amp; (this.y === 0) &amp;&amp; (this.z === 0) &amp;&amp; (this.yz === 0) &amp;&amp; (this.zx === 0) &amp;&amp; (this.xy === 0) &amp;&amp; (this.xyz === 0);
    }
    length() {
      return Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z + this.xy * this.xy + this.yz * this.yz + this.zx * this.zx + this.xyz * this.xyz);
    }

    cos(): Euclidean3 {
      // TODO: Generalize to full multivector.
      Unit.assertDimensionless(this.uom);
      var cosW = cos(this.w);
      return new Euclidean3(cosW, 0, 0, 0, 0, 0, 0, 0, void 0);
    }

    cosh(): Euclidean3 {
      //Unit.assertDimensionless(this.uom);
      throw new NotImplementedError(&#x27;cosh(Euclidean3)&#x27;);
    }

    exp(): Euclidean3 {
      Unit.assertDimensionless(this.uom);
      var bivector = this.grade(2);
      var a = bivector.norm();
      if (!a.isZero()) {
        var c = a.cos();
        var s = a.sin();
        var B = bivector.unit();
        return c.add(B.mul(s));
      }
      else {
        return new Euclidean3(1, 0, 0, 0, 0, 0, 0, 0, this.uom);
      }
    }

    /**
     * Computes the magnitude of this Euclidean3. The magnitude is the square root of the quadrance.
     */
    norm(): Euclidean3 {return new Euclidean3(Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z + this.xy * this.xy + this.yz * this.yz + this.zx * this.zx + this.xyz * this.xyz), 0, 0, 0, 0, 0, 0, 0, this.uom);}

    /**
     * Computes the quadrance of this Euclidean3. The quadrance is the square of the magnitude.
     */
    quad(): Euclidean3 {
      return new Euclidean3(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z + this.xy * this.xy + this.yz * this.yz + this.zx * this.zx + this.xyz * this.xyz, 0, 0, 0, 0, 0, 0, 0, Unit.mul(this.uom, this.uom));
    }

    sin(): Euclidean3 {
      // TODO: Generalize to full multivector.
      Unit.assertDimensionless(this.uom);
      var sinW = sin(this.w);
      return new Euclidean3(sinW, 0, 0, 0, 0, 0, 0, 0, void 0);
    }

    sinh(): Euclidean3 {
      //Unit.assertDimensionless(this.uom);
      throw new Euclidean3Error(&#x27;sinh&#x27;);
    }

    unit(): Euclidean3 {
      return this.div(this.norm());
    }

    scalar(): number {
      return this.w;
    }

    sqrt() {
      return new Euclidean3(Math.sqrt(this.w), 0, 0, 0, 0, 0, 0, 0, Unit.sqrt(this.uom));
    }

    toStringCustom(
      coordToString: (x: number) =&gt; string,
      labels: string[]): string {
      var quantityString: string = stringFromCoordinates(this.coordinates(), coordToString, labels);
      if (this.uom) {
        var unitString = this.uom.toString().trim();
        if (unitString) {
          return quantityString + &#x27; &#x27; + unitString;
        }
        else {
          return quantityString;
        }
      }
      else {
        return quantityString;
      }
    }

    toExponential(): string {
      var coordToString = function(coord: number): string { return coord.toExponential() };
      return this.toStringCustom(coordToString, [&quot;1&quot;, &quot;e1&quot;, &quot;e2&quot;, &quot;e3&quot;, &quot;e12&quot;, &quot;e23&quot;, &quot;e31&quot;, &quot;e123&quot;]);
    }

    toFixed(digits?: number): string {
      assertArgNumber(&#x27;digits&#x27;, digits);
      var coordToString = function(coord: number): string { return coord.toFixed(digits) };
      return this.toStringCustom(coordToString, [&quot;1&quot;, &quot;e1&quot;, &quot;e2&quot;, &quot;e3&quot;, &quot;e12&quot;, &quot;e23&quot;, &quot;e31&quot;, &quot;e123&quot;]);
    }

    toString(): string {
      var coordToString = function(coord: number): string { return coord.toString() };
      return this.toStringCustom(coordToString, [&quot;1&quot;, &quot;e1&quot;, &quot;e2&quot;, &quot;e3&quot;, &quot;e12&quot;, &quot;e23&quot;, &quot;e31&quot;, &quot;e123&quot;]);
    }

    toStringIJK(): string {
      var coordToString = function(coord: number): string { return coord.toString() };
      return this.toStringCustom(coordToString, [&quot;1&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;ij&quot;, &quot;jk&quot;, &quot;ki&quot;, &quot;I&quot;]);
    }

    toStringLATEX(): string {
      var coordToString = function(coord: number): string { return coord.toString() };
      return this.toStringCustom(coordToString, [&quot;1&quot;, &quot;e_{1}&quot;, &quot;e_{2}&quot;, &quot;e_{3}&quot;, &quot;e_{12}&quot;, &quot;e_{23}&quot;, &quot;e_{31}&quot;, &quot;e_{123}&quot;]);
    }
}

export = Euclidean3;
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
